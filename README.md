## Hardware implementation of OCaml using a synchronous functional language

This artefact, presented in the paper, includes:
- a compiler for the Eclat language (`eclat-compiler/`) based on an existing work by `Sylvestre et al.: Work-in-Progress: mixing computation and interaction on FPGA. In: 2023 International Conference on Embedded Software (EMSOFT ’23). pp. 5–6. IEEE (2023)` for a smaller language;
- an implementation of the OCaml virtual machine (VM) in Eclat (`ocaml-vm/`);
- benchmarks from the paper (`benchs/`), with also hardware-accelerated 
  versions (e.g., `benchs/gcd/README.md`) and instructions to reproduce;
- Eclat examples (listings) from the paper, with execution traces (e.g. `examples/counter.png`) and instructions to reproduce;
- a folder `target` in which the generated code is automatically written,
  including a main component `main.vhdl`,
  a testbench `tb_main.vhdl` (for simulation)
  and an interface `top.vhdl` (for synthesis);
  Eclat instantaneous primitives are defined in `target/runtime.vhdl`


The paper compares our VM implementation with an other implementation of the OCaml VM, called OMicroB ([https://github.com/stevenvar/OMicroB](https://github.com/stevenvar/OMicroB)) and a port of OMicroB on FPGA ([https://github.com/jserot/O2B](https://github.com/jserot/O2B))

-------------------

The VM includes :
- a configuration file (`ocaml-vm/bytecode.ecl`) generated by our auxiliary `ocaml-vm/bc` from the output of the OCaml bytecode compiler;
- value representation (`ocaml-vm/mlvalues.ecl`);
- dynamic memory in a static array (`ocaml-vm/ram.ecl`);
- a memory allocator with garbage collector Stop&Copy  (`ocaml-vm/allloc.ecl`);
- the primitives of the bytecode interpreter (`ocaml-vm/runtime.ecl`);
- external primitives (`ocaml-vm/prims.ecl`);
- a bytecode interpreter (`ocaml-vm/vm.ecl`);
- a reactive program executing the VM internally (`ocaml-vm/main.ecl`).


Installation
------------

To build from source, the pre-requisites are:

* `opam` 
* `ocaml 4.14.1`
* `menhir`
* `ocamlclean`
* `obytelib`
* `dune`
* for simulation: `ghdl` and `GTKWave`
* for synthesis: `Intel Quartus II 22.1 lite`, on a 
  Terasic DE10-lite board (having an Intel MAX 10 FPGA)


Quick example (in simulation mode)
-------

```
$ make vm SRC=ocaml-vm/tests/fibo.ml
$ make simul NS=200000

...

pc:19|acc:55<int>|sp:1011|env:4000<ptr> 
pc:20|acc:89<int>|sp:1010|env:4000<ptr> 
pc:19|acc:89<int>|sp:1006|env:4000<ptr> 
pc:20|acc:144<int>|sp:1005|env:4000<ptr> 
pc:30|acc:144<int>|sp:1001|env:1<int> 
======> 144 
pc:32|acc:1<int>|sp:1001|env:1<int> 
pc:34|acc:1<int>|sp:1000|env:1<int> 
STOP : cycle:16427 
pc:34|acc:1<int>|sp:1000|env:1<int> 
cycle:16428 
cycle:16429 
STOP : cycle:16430 
pc:34|acc:1<int>|sp:1000|env:1<int> 
^C
$
```